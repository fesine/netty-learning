为了提高程序的运行性能，现代CPU在很多方面对程序进行了优化。
一、CPU高速缓存。尽可能避免处理器访问主内存的时间开销，处理器大都会利用缓存(cache)以提高性能。
多级缓存，L1 cache（通常32-4096k），存储数据和指令，L2 cache，L3 cache
CPU在读取数据时，先从L1寻找，再到L2寻找，再到L3寻找，然后是主内存寻找，最后是外存储器。

缓存同步协议，MESI协议，定义4个状态：
1、修改态，表示此cache行已经被修改（脏行），内容已不同于主内存，为此cache专有；
2、专有态，表示此cache行内容同于主存，但不出现在其他cache中；
3、共享态，表示此cache行内容同于主存，但也出现在其他cache中；
4、无效态，表示此cache行内容无效（空行）。

多处理器时，单个CPU对缓存中数据进行了改动，需要通知其他CPU;
意味着CPU处理要控制自己的读写操作，还要监听其他CPU发出的通知，从而保证最终一致。

二、运行时指令重排
//代码         //正常步骤          //重排步骤
x=100;        1、将100写入x       1、读取z的值
y=z;          2、读取z的值         2、将z的值写入y
              3、将z的值写入y      3、将100写入x
指令重排场景：当CPU写缓存时发现缓存区块正被其他CPU占用，为了提高CPU性能，可能将后面的读缓存命令优先执行。
重排需要遵循 as-if-serial语义
不管怎么重排序，单线程下执行结果不能被改变。
编译器和处理器都需要遵循as-if-serial语义，也就是说编译器和处理器不会对存在依赖的数据进行重排序。

由此存在两个问题
1、CPU高速缓存下有一个问题：
缓存中的数据与主内存的数据并不是实时同步的，各CPU间缓存的数据也不是实时同步。
即在同一个时间点，各CPU所看到同一内存地址的数据值可能是不一致的。

2、CPU执行指令重排序优化下有一个问题：
虽然遵守了as-if-serial协议，单仅在单CPU执行的情况下能保证结果正确。
多核线程中，指令逻辑无法分辨因果关联，可能出现乱序执行，导致程序运行结果错误。

如何解决上述两个问题
处理器提供了两个内存屏障（Memory Barrier）指令，用于解决上述两个问题。
写内存屏障（Store Memory Barrier）：在指令后插入Store Barrier，能让最新写入缓存的数据，更新到主内存，
让其他内存可见；强制写入主内存，这种显式调用，CPU就不会因为性能考虑而去对指令重排
读内存屏障（Load Memory Barrier）：在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从主内存中加载数据。
强制读取主内存，让CPU缓存与主内存保持一致，避免了缓存导致的一致性问题。

以上知识点为JVM线程安全问题作铺垫。
