wait/notify机制
这些方法只能由同一对象锁持有者的线程调用，也就是在同步代码块中，否则会抛出IllegalMonitorStateException.
wait方法导致当前线程等待，加入该对象的等待集合中，并且释放当前持有的对象锁。
notify/notifyAll唤醒一个或所有正在等这个对象锁的线程。
注意：wait虽然会自动解锁，但对顺序有要求，如果notify被调用后，才开始wait方法的调用，则线程永久处理WAITING状态。

park/unpark机制
线程调用park则等待"许可"，unpark方法为指定线程提供"许可"。
不要求park与unpark方法的执行顺序。
多次调用unpark后，再次调用park方法，线程会直接运行。
但不会叠加unpark，也就是说连续多次调用park方法后，第一次拿到"许可"直接运行，后续调用会进入等待。

所以其实，官方不推荐使用suspend&resume主要原因在于死锁和执行顺序要求严格
而wait/notify只解决了死锁问题，但没解决执行顺序
同理park/unpark解决了执行顺序，但没解决死锁问题

最后需要注意的是伪唤醒问题
demo6中的判断进入等待的方法是使用if判断，官方推荐在while循环中检查判断条件，原因在于处于等待的线程可能会收到
错误警报和伪唤醒，导致线程继续执行，而如果在while循环中，唤醒线程会再次判断执行条件是否满足，
只要不是notify和unpark唤醒，都将不满足执行条件。
其原因是更底层原因导致的。